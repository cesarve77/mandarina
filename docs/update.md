---
title: Update
---

    
*e.g.*:

```typescript jsx
import React from 'react'
import {Update} from 'mandarina'
import Like from '../tables/Like'
import Button from '../components/Button'
import Input from '../components/Input'
import Loading from '../components/Loading'

const UpdateComment= ({comment,commentId,userId,onChange} )=>{
    return (
        <>
            <Input value={comment} onChange={onChange}/> //supposed we are handling value state in the parent component
            <Update table={Like} id={commentId}>
                {({mutate,loading}) => {
                    if (loading) return <Loading/>
                    return (
                        <Button onClick={()=>mutate({comment})} >
                            Save
                        </Button>
                    )
                }}
            </Update>
        </>
    )
}

```

## Properties

### 1.1) children

*type*:  (mutate: Function, result: MutationResult) => React.ReactNode

*description*: A function that allows you to trigger a mutation from your UI. Required

#### 1.1.1) mutate

*type*: (model: Model) => Promise

*description*: A function to trigger a mutation from your UI. 

##### 1.1.1.1) model

*type*: Object

*description*: A object with the table shape. for child table going to be connected (no creating) use as a child object with the id 

*e.g. connect*:

```typescript jsx
const model={
    name: 'John',
    status: {id: 'cjh0wd3xp00o10b42ung91zjh'}, //connecting with a exiting status
    children:[ //creating 2 new persons
        {
            name: 'Johny',
            status: {id: 'cjh0wd3xp00o10b42ung91zjh'} //connecting with a exiting status
        },
         {
            name: 'Jena',
            status: {id: 'cjh0wd3xp00o10b42ung91zjh'} //connecting with a exiting status
         }
    ]
}

//the model above suits for the following Tables, and it will create three persons (John, Johny, Jena) and connected then to status 'cjh0wd3xp00o10b42ung91zjh'

const Person=new Table({
    name: {type: String} ,
    status: {type: 'Status'} ,
    children: {type: ['Person']}
})

const Status=new Table({
    status: {type: String} ,
})

```

#### 1.1.2) data

*type*: TData

*description*: The data returned from your mutation. It can be undefined if ignoreResults is true.

#### 1.1.3) loading

*type*: boolean

*description*: A boolean indicating whether your mutation is in flight

#### 1.1.4) error

*type*: ApolloError
 
*description*: Any errors returned from the mutation

#### 1.1.5) called

*type*: boolean
 
*description*: A boolean indicating if the mutate function has been called

#### 1.1.6) client

*type*: ApolloClient
 
*description*: Your ApolloClient instance. Useful for invoking cache methods outside the context of the update function, such as client.writeData and client.readQuery.


### 1.2) variables

*type*: { [key: string]: any }

*description*: An object containing all of the variables your mutation needs to execute

### 1.3) update

*type*: (cache: DataProxy, mutationResult: FetchResult)

*description*: A function used to update the cache after a mutation occurs

### 1.4) ignoreResults

*type*: boolean

*description*: If true, the data property on the render prop function will not update with the mutation result.

*default*: false

### 1.5) optimisticResponse

*type*: Object | false

*description*: normally you don't need to pass this value, the optimistic response will be handle automatically by the component. Provide a mutation response before the result comes back from the server.

*default*: Autogenerated object base in the model.

### 1.6) refetchQueries

*type*: (mutationResult: FetchResult) => Array<{ query: DocumentNode, variables?: TVariables} | string>

*description*: A function that allows you to specify which queries you want to refetch after a mutation has occurred

### 1.7) awaitRefetchQueries

*type*: boolean

*description*: Queries refetched as part of refetchQueries are handled asynchronously, and are not waited on before the mutation is completed (resolved). Setting this to true will make sure refetched queries are completed before the mutation is considered done. false by default.

### 1.8) onCompleted

*type*: (data: TData) => void

*description*: A callback executed once your mutation successfully completes

### 1.9) onError

*type*: (error: ApolloError) => void

*description*: A callback executed in the event of an error

### 1.10) context

*type*: Record<string, any>

*description*: Shared context between your Mutation component and your network interface (Apollo Link). Useful for setting headers from props or sending information to the request function of Apollo Boost.